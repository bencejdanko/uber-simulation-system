import { Request, Response, NextFunction } from 'express';
import * as PasswordService from '../../services/password.service';
import * as TokenService from '../../services/token.service';
import { AuthModel } from '../../models/auth.model';
import { publishUserRegistered, UserRegisteredPayload } from '../../kafka/producer';
import { RegisterCustomerInput, RegisterDriverInput, LoginInput } from '../../schemas/auth.schemas';

export const registerCustomer = async (req: Request<{}, {}, RegisterCustomerInput>, res: Response, next: NextFunction): Promise<void> => {
    try {
        const { email, password, firstName, lastName, phoneNumber } = req.body;

        // 1. Check if user exists
        const existingUser = await AuthModel.findOne({ email });
        if (existingUser) {
            res.status(409).json({ error: { code: 'USER_ALREADY_EXISTS', message: 'Email already in use.' } });
            return;
        }

        // 2. Hash password (using PasswordService)
        const hashedPassword = await PasswordService.hashPassword(password);

        // 3. Create user
        const newUser = await AuthModel.create({
            email,
            hashedPassword,
            userType: 'CUSTOMER',
            // userId is generated by default in the model
        });

        // 4. Generate token (simplified - no refresh token)
        const accessToken = TokenService.generateAccessToken({ userId: newUser.userId, userType: newUser.userType });

        // 5. Publish event (async, don't necessarily wait unless critical)
        const eventPayload: UserRegisteredPayload = {
            userId: newUser.userId,
            userType: newUser.userType,
            email: newUser.email,
            firstName,
            lastName,
            phoneNumber,
            timestamp: new Date().toISOString(),
        };
        publishUserRegistered(eventPayload).catch(err => {
            console.error("Failed to publish registration event asynchronously:", err);
            // Potentially add to a retry queue or log for monitoring
        });

        // 6. Return response
        res.status(201).json({ accessToken });

    } catch (error) {
        next(error); // Pass to global error handler
    }
};

export const registerDriver = async (req: Request<{}, {}, RegisterDriverInput>, res: Response, next: NextFunction): Promise<void> => {
    try {
        const { email, password, firstName, lastName, phoneNumber } = req.body;

        // 1. Check if user exists
        const existingUser = await AuthModel.findOne({ email });
        if (existingUser) {
            res.status(409).json({ error: { code: 'USER_ALREADY_EXISTS', message: 'Email already in use.' } });
            return;
        }

        // 2. Hash password (using PasswordService)
        const hashedPassword = await PasswordService.hashPassword(password);

        // 3. Create user
        const newUser = await AuthModel.create({
            email,
            hashedPassword,
            userType: 'DRIVER',
            // userId is generated by default in the model
        });

        // 4. Generate token (simplified - no refresh token)
        const accessToken = TokenService.generateAccessToken({ userId: newUser.userId, userType: newUser.userType });

        // 5. Publish event (async, don't necessarily wait unless critical)
        const eventPayload: UserRegisteredPayload = {
            userId: newUser.userId,
            userType: newUser.userType,
            email: newUser.email,
            firstName,
            lastName,
            phoneNumber,
            // Add driver-specific fields
            // licenseNumber,
            // vehicleInfo,
            timestamp: new Date().toISOString(),
        };
        publishUserRegistered(eventPayload).catch(err => {
            console.error("Failed to publish registration event asynchronously:", err);
            // Potentially add to a retry queue or log for monitoring
        });

        // 6. Return response
        res.status(201).json({ accessToken });

    } catch (error) {
        next(error); // Pass to global error handler
    }
};

export const login = async (req: Request<{}, {}, LoginInput>, res: Response, next: NextFunction): Promise<void> => {
    try {
        const { email, password } = req.body;
        
        // Find user by email
        const user = await AuthModel.findOne({ email });
        if (!user) {
            res.status(401).json({ error: { code: 'INVALID_CREDENTIALS', message: 'Invalid email or password.' } });
            return;
        }
        
        // Validate password
        const isPasswordValid = await PasswordService.comparePassword(password, user.hashedPassword);
        if (!isPasswordValid) {
            res.status(401).json({ error: { code: 'INVALID_CREDENTIALS', message: 'Invalid email or password.' } });
            return;
        }

        // Generate token (simplified - no refresh token)
        const accessToken = TokenService.generateAccessToken({ userId: user.userId, userType: user.userType });
        
        res.status(200).json({ accessToken });

    } catch (error) {
        next(error);
    }
};